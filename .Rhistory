}
i <- 1
while (!is.na(is_file_readable[i])) {
print(is_file_readable[i])
i=i+1
}
is_file_readable
is_file_readable
names(is_file_readable)
is_file_readable
output_data
output_data <-
tibble::tibble()
tibble()
dplyr::tibble()
is(output_data, "try-error")
is(dplyr::tibble(), "try-error")
!is(dplyr::tibble(), "try-error")
is(dplyr::tibble(), "try-error")
is(output_data, "try-error")
output_data
get_data <- function(data_list) {
# Check if the data_list is readable
is_file_readable <- is_readable(data_list)
# If readable, get data
# If not, get tibble with URL
if (length(is_file_readable) != 0) {
# Get the first format.
format_to_read <- is_file_readable[1]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
# The encoding argument is only available for the formats below, so
# it should be added only when that format is the one being read.
# I use is_file_readable and the data forms without the . because
# it's easier to match than data_format which has two slashes
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
# This encoding does not work perfectly. Sometimes
# it does't work and UTF-8 captures spanish accents but
# other times it doesn't.
}
# Try reading the data
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
# If there's any error, try again with next format. If cannot read any, return an empty tibble
if (is(output_data, "try-error")) {
while(is(output_data, "try-error")) {
next_attempt <- 2
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
}
} else {
output_data <- dplyr::tibble(extract_url_format(data_list),
extract_access_url(data_list))
names(output_data) <- c("format", "URL")
}
} else {
output_data <- dplyr::tibble(extract_url_format(data_list),
extract_access_url(data_list))
names(output_data) <- c("format", "URL")
}
# Output
output_data
}
format_to_read
is_file_readable
is_file_readable[1] <- "http://opendata-ajuntament.barcelona.cat/resources/opendata/2011_N_EDIF_HAB_SEGONS_NOMBRE_PLANTES2011.c"
is_file_readable
is_file_readable[1]
is_file_readable[2]
s_file_readable[1]
is_file_readable[1]
is_file_readable[2]
id <- 'l01080193-numero-total-de-edificios-con-viviendas-segun-numero-de-plantas'
resp <- get_resp(path_dataset_id(id))
data_list <- resp$result$items[[1]]
is_file_readable <- is_readable(data_list)
is_file_readable
names(is_file_readable[1])
names(is_file_readable[1]) <- "http://opendata-ajuntament.barcelona.cat/resources/opendata/2011_N_EDIF_HAB_SEGONS_NOMBRE_PLANTES2011.c"
get_data(data_list)
# Check if the data_list is readable
is_file_readable <- is_readable(data_list)
is_file_readable
is_readable(data_list)
names(is_file_readable[1])
names(is_file_readable[1]) <- ""http://opendata-ajuntament.barcelona.cat/resources/opendata/2011_N_EDIF_HAB_SEGONS_NOMBRE_PLANTES2011.c""
names(is_file_readable[1]) <- http://opendata-ajuntament.barcelona.cat/resources/opendata/2011_N_EDIF_HAB_SEGONS_NOMBRE_PLANTES2011.c"
names(is_file_readable[1]) <- "http://opendata-ajuntament.barcelona.cat/resources/opendata/2011_N_EDIF_HAB_SEGONS_NOMBRE_PLANTES2011.c"
length(is_file_readable) != 0
# Get the first format.
format_to_read <- is_file_readable[1]
format_to_read
is_file_readable[1]
names(format_to_read)
# Get the first format.
format_to_read <- is_file_readable[1]
format_to_read
names(format_to_read[1])
names(format_to_read)
names(format_to_read)<-"http://opendata-ajuntament.barcelona.cat/resources/opendata/2011_N_EDIF_HAB_SEGONS_NOMBRE_PLANTES2011.c"
names(format_to_read)
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
format_to_read
format_to_read %in% c("csv", "html", "xml")
args_rio <- c(args_rio, "encoding" = "UTF-8")
# Try reading the data
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
args_rio
is(output_data, "try-error")
while(is(output_data, "try-error")) {
next_attempt <- 2
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
}
output_data
next_attempt <- 2
format_to_read <- is_file_readable[next_attempt]
is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
is(output_data, "try-error")
get_data <- function(data_list) {
# Check if the data_list is readable
is_file_readable <- is_readable(data_list)
# If readable, get data
# If not, get tibble with URL
if (length(is_file_readable) != 0) {
# Get the first format.
format_to_read <- is_file_readable[1]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
# The encoding argument is only available for the formats below, so
# it should be added only when that format is the one being read.
# I use is_file_readable and the data forms without the . because
# it's easier to match than data_format which has two slashes
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
# This encoding does not work perfectly. Sometimes
# it does't work and UTF-8 captures spanish accents but
# other times it doesn't.
}
# Try reading the data
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
# If there's any error, try again with next format. If cannot read any, return an empty tibble
if (is(output_data, "try-error")) {
while(is(output_data, "try-error")) {
next_attempt <- 2
if (length(is_file_readable) != 0) {
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
}
}
} else {
output_data <- dplyr::tibble(extract_url_format(data_list),
extract_access_url(data_list))
names(output_data) <- c("format", "URL")
}
} else {
output_data <- dplyr::tibble(extract_url_format(data_list),
extract_access_url(data_list))
names(output_data) <- c("format", "URL")
}
# Output
output_data
}
is_file_readable
# Check if the data_list is readable
is_file_readable <- is_readable(data_list)
length(is_file_readable) != 0
# Get the first format.
format_to_read <- is_file_readable[1]
format_to_read
names(format_to_read)
names(format_to_read) <- "http://opendata-ajuntament.barcelona.cat/resources/opendata/2011_N_EDIF_HAB_SEGONS_NOMBRE_PLANTES2011.c"
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
args_rio
format_to_read %in% c("csv", "html", "xml")
args_rio <- c(args_rio, "encoding" = "UTF-8")
# Try reading the data
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
is(output_data, "try-error")
next_attempt <- 2
length(is_file_readable) != 0
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
format_to_read %in% c("csv", "html", "xml")
try(do.call(rio::import, args_rio), silent = TRUE)
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
is(output_data, "try-error")
is(output_data, "try-error")
output_data <- NULL
is(output_data, "try-error")
output_data
id <- 'l01080193-numero-total-de-edificios-con-viviendas-segun-numero-de-plantas'
resp <- get_resp(path_dataset_id(id))
source('~/Google Drive/datos_gob/R/get_data.R', echo=TRUE)
resp <- get_resp(path_dataset_id(id))
get_data <- function(data_list) {
# Check if the data_list is readable
is_file_readable <- is_readable(data_list)
# If readable, get data
# If not, get tibble with URL
if (length(is_file_readable) != 0) {
# Get the first format.
format_to_read <- is_file_readable[1]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
# The encoding argument is only available for the formats below, so
# it should be added only when that format is the one being read.
# I use is_file_readable and the data forms without the . because
# it's easier to match than data_format which has two slashes
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
# This encoding does not work perfectly. Sometimes
# it does't work and UTF-8 captures spanish accents but
# other times it doesn't.
}
# Try reading the data
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
# If there's any error, return an empty tibble
if (is(output_data, "try-error")) {
output_data <- dplyr::tibble(extract_url_format(data_list),
extract_access_url(data_list))
names(output_data) <- c("format", "URL")
}
} else {
output_data <- dplyr::tibble(extract_url_format(data_list),
extract_access_url(data_list))
names(output_data) <- c("format", "URL")
}
# Output
output_data
}
source('~/Google Drive/datos_gob/R/utils.R', echo=TRUE)
resp <- get_resp(path_dataset_id(id))
source('~/Google Drive/datos_gob/R/utils.R', echo=TRUE)
source('~/Google Drive/datos_gob/R/path_api.R', echo=TRUE)
source('~/Google Drive/datos_gob/R/is_readable.R', echo=TRUE)
source('~/Google Drive/datos_gob/R/get_data.R', echo=TRUE)
resp <- get_resp(path_dataset_id(id))
source('~/Google Drive/datos_gob/R/path_api.R', echo=TRUE)
resp <- get_resp(path_dataset_id(id))
data_list <- resp$result$items[[1]]
is_readable(data_list)
source('~/Google Drive/datos_gob/R/extract_datos.R', echo=TRUE)
source('~/Google Drive/datos_gob/R/extract_components.R', echo=TRUE)
source('~/Google Drive/datos_gob/R/datos_publishers.R', echo=TRUE)
is_readable(data_list)
# Check if the data_list is readable
is_file_readable <- is_readable(data_list)
length(is_file_readable) != 0
# Get the first format.
format_to_read <- is_file_readable[1]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
# The encoding argument is only available for the formats below, so
# it should be added only when that format is the one being read.
# I use is_file_readable and the data forms without the . because
# it's easier to match than data_format which has two slashes
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
# This encoding does not work perfectly. Sometimes
# it does't work and UTF-8 captures spanish accents but
# other times it doesn't.
}
# Try reading the data
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
output_data
class(output_data)
is_file_readable[1]
names(format_to_read)
names(format_to_read)<-"http://opendata-ajuntament.barcelona.cat/resources/opendata/2011_N_EDIF_HAB_SEGONS_NOMBRE_PLANTES2011.c"
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
# The encoding argument is only available for the formats below, so
# it should be added only when that format is the one being read.
# I use is_file_readable and the data forms without the . because
# it's easier to match than data_format which has two slashes
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
# This encoding does not work perfectly. Sometimes
# it does't work and UTF-8 captures spanish accents but
# other times it doesn't.
}
# Try reading the data
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
class(output_data)
output_data
next_attempts <- function(output_data, is_file_readable, format_to_read) {
while(is(output_data, "try-error")) {
next_attempt <- 2
if (length(is_file_readable) != 0) {
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
}
}
}
next_attempts <- function(output_data, is_file_readable, format_to_read) {
while(is(output_data, "try-error")) {
next_attempt <- 1
if (length(is_file_readable) != 0) {
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
}
}
}
names(format_to_read)
is(output_data, "try-error")
next_attempts(output_data = output_data, is_file_readable = is_file_readable, format_to_read = format_to_read)
output_data
next_attempts <- function(output_data, is_file_readable, format_to_read) {
while(is(output_data, "try-error")) {
next_attempt <- 1
if (length(is_file_readable) != 0) {
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
}
}
output_data
}
next_attempts(output_data = output_data, is_file_readable = is_file_readable, format_to_read = format_to_read)
output_data
next_attempts <- function(output_data, is_file_readable, format_to_read) {
while(is(output_data, "try-error")) {
next_attempt <- 1
if (length(is_file_readable) != 0) {
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <<- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
}
}
}
next_attempts(output_data = output_data, is_file_readable = is_file_readable, format_to_read = format_to_read)
next_attempts <- function(output_data, is_file_readable, format_to_read) {
while(is(output_data, "try-error")) {
next_attempt <- 1
if (length(is_file_readable) != 0) {
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
}
}
}
setwd("~/Google Drive/datos_gob/R")
file.sources = list.files(pattern="*.R")
sapply(file.sources,source)
id <- 'l01080193-numero-total-de-edificios-con-viviendas-segun-numero-de-plantas'
resp <- get_resp(path_dataset_id(id))
source('~/Google Drive/datos_gob/R/path_api.R', echo=TRUE)
resp <- get_resp(path_dataset_id(id))
data_list <- resp$result$items[[1]]
next_attempts <- function(output_data, is_file_readable, format_to_read) {
while(is(output_data, "try-error")) {
next_attempt <- 1
if (length(is_file_readable) != 0) {
format_to_read <- is_file_readable[next_attempt]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
}
output_data <<- try(do.call(rio::import, args_rio), silent = TRUE)
next_attempt <- next_attempt + 1
}
}
}
# Check if the data_list is readable
is_file_readable <- is_readable(data_list)
length(is_file_readable) != 0
# Get the first format.
format_to_read <- is_file_readable[1]
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
names(format_to_read)
names(format_to_read)<-"http://opendata-ajuntament.barcelona.cat/resources/opendata/2011_N_EDIF_HAB_SEGONS_NOMBRE_PLANTES2011.c"
args_rio <-
list(file = names(format_to_read),
format = format_to_read,
setclass = "tibble")
# The encoding argument is only available for the formats below, so
# it should be added only when that format is the one being read.
# I use is_file_readable and the data forms without the . because
# it's easier to match than data_format which has two slashes
if (format_to_read %in% c("csv", "html", "xml")) {
args_rio <- c(args_rio, "encoding" = "UTF-8")
# This encoding does not work perfectly. Sometimes
# it does't work and UTF-8 captures spanish accents but
# other times it doesn't.
}
# Try reading the data
output_data <- try(do.call(rio::import, args_rio), silent = TRUE)
is(output_data, "try-error")
next_attempts(output_data = output_data, is_file_readable = is_file_readable, format_to_read = format_to_read)
is_file_readable
output_data
format_to_read
length(is_file_readable) != 0
x <- c(1, 2, 3, 4)
x[-1]
x <- x[-1]
x
x <- x[-1]
x
search()
x <- 1
x
x <- x[-1]
x
length(x) != 0
install.packages("microdataess")
install.packages("microdatoses")
install.packages("MicroDatosEs")
MicroDatosEs::ees2010
?MicroDatosEs::ees2010
cargar_publicador()
stop()
devtools::install()
opendataes::
devtools::install()
